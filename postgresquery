-- ============================================================================
-- PostgreSQL Complete Practice Guide
-- Real-world e-commerce database example
-- ============================================================================

-- ============================================================================
-- SECTION 1: DATABASE SETUP
-- ============================================================================

-- List all databases
SELECT datname FROM pg_database;

-- Create database
CREATE DATABASE ecommerce_db;

-- Connect to database
\c ecommerce_db

-- Drop database (careful!)
-- DROP DATABASE IF EXISTS ecommerce_db;


-- ============================================================================
-- SECTION 2: EXTENSIONS
-- ============================================================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";       -- UUID generation
CREATE EXTENSION IF NOT EXISTS "pgcrypto";        -- Encryption functions


-- ============================================================================
-- SECTION 3: SCHEMA CREATION (Parent tables first)
-- ============================================================================

-- Users table
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    full_name VARCHAR(100) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Categories table
CREATE TABLE categories (
    category_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) UNIQUE NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    parent_category_id UUID REFERENCES categories(category_id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Products table
CREATE TABLE products (
    product_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    category_id UUID NOT NULL REFERENCES categories(category_id) ON DELETE RESTRICT,
    name VARCHAR(200) NOT NULL,
    slug VARCHAR(200) UNIQUE NOT NULL,
    description TEXT,
    price NUMERIC(10, 2) NOT NULL CHECK (price >= 0),
    stock_quantity INTEGER NOT NULL DEFAULT 0 CHECK (stock_quantity >= 0),
    sku VARCHAR(50) UNIQUE NOT NULL,
    is_active BOOLEAN DEFAULT true,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Addresses table
CREATE TABLE addresses (
    address_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    address_type VARCHAR(20) CHECK (address_type IN ('shipping', 'billing')),
    street_address VARCHAR(255) NOT NULL,
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    postal_code VARCHAR(20) NOT NULL,
    country VARCHAR(100) NOT NULL,
    is_default BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Orders table
CREATE TABLE orders (
    order_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE RESTRICT,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'shipped', 'delivered', 'cancelled')),
    total_amount NUMERIC(10, 2) NOT NULL CHECK (total_amount >= 0),
    shipping_address_id UUID REFERENCES addresses(address_id),
    payment_method VARCHAR(50),
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Order items table (junction table)
CREATE TABLE order_items (
    order_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE RESTRICT,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price NUMERIC(10, 2) NOT NULL CHECK (unit_price >= 0),
    subtotal NUMERIC(10, 2) NOT NULL CHECK (subtotal >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Reviews table
CREATE TABLE reviews (
    review_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    rating INTEGER NOT NULL CHECK (rating BETWEEN 1 AND 5),
    title VARCHAR(200),
    comment TEXT,
    is_verified_purchase BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(product_id, user_id)
);


-- ============================================================================
-- SECTION 4: INDEXES (Performance optimization)
-- ============================================================================

-- B-tree indexes for frequent lookups
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_orders_user ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- Partial indexes (only active records)
CREATE INDEX idx_active_products ON products(product_id) WHERE is_active = true;
CREATE INDEX idx_active_users ON users(user_id) WHERE is_active = true;

-- GIN index for JSONB columns
CREATE INDEX idx_products_metadata ON products USING GIN(metadata);

-- Composite index for common queries
CREATE INDEX idx_products_category_active ON products(category_id, is_active);

-- Index on created_at for time-based queries
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);


-- ============================================================================
-- SECTION 5: INSERT DATA (Seed data)
-- ============================================================================

-- Insert users
INSERT INTO users (email, full_name, password_hash, phone) VALUES
('john.doe@email.com', 'John Doe', crypt('password123', gen_salt('bf')), '+1234567890'),
('jane.smith@email.com', 'Jane Smith', crypt('password123', gen_salt('bf')), '+1234567891'),
('bob.wilson@email.com', 'Bob Wilson', crypt('password123', gen_salt('bf')), '+1234567892'),
('alice.brown@email.com', 'Alice Brown', crypt('password123', gen_salt('bf')), '+1234567893'),
('charlie.davis@email.com', 'Charlie Davis', crypt('password123', gen_salt('bf')), '+1234567894');

-- Insert categories (parent first)
INSERT INTO categories (name, slug, description) VALUES
('Electronics', 'electronics', 'Electronic devices and accessories'),
('Clothing', 'clothing', 'Apparel and fashion items'),
('Books', 'books', 'Physical and digital books');

-- Insert subcategories
INSERT INTO categories (name, slug, description, parent_category_id)
SELECT 'Laptops', 'laptops', 'Portable computers', category_id FROM categories WHERE slug = 'electronics'
UNION ALL
SELECT 'Smartphones', 'smartphones', 'Mobile phones', category_id FROM categories WHERE slug = 'electronics'
UNION ALL
SELECT 'Men Clothing', 'men-clothing', 'Mens fashion', category_id FROM categories WHERE slug = 'clothing';

-- Insert products
INSERT INTO products (category_id, name, slug, description, price, stock_quantity, sku, metadata) VALUES
(
    (SELECT category_id FROM categories WHERE slug = 'laptops'),
    'MacBook Pro 16"',
    'macbook-pro-16',
    'High-performance laptop with M2 chip',
    2499.99,
    15,
    'LAPTOP-MBP16-001',
    '{"brand": "Apple", "warranty_years": 1, "specs": {"ram": "16GB", "storage": "512GB"}}'::jsonb
),
(
    (SELECT category_id FROM categories WHERE slug = 'laptops'),
    'Dell XPS 15',
    'dell-xps-15',
    'Premium Windows laptop',
    1799.99,
    20,
    'LAPTOP-DXPS15-001',
    '{"brand": "Dell", "warranty_years": 1, "specs": {"ram": "16GB", "storage": "1TB"}}'::jsonb
),
(
    (SELECT category_id FROM categories WHERE slug = 'smartphones'),
    'iPhone 15 Pro',
    'iphone-15-pro',
    'Latest iPhone with A17 chip',
    999.99,
    50,
    'PHONE-IP15P-001',
    '{"brand": "Apple", "warranty_years": 1, "specs": {"storage": "256GB", "color": "Titanium"}}'::jsonb
),
(
    (SELECT category_id FROM categories WHERE slug = 'smartphones'),
    'Samsung Galaxy S24',
    'samsung-galaxy-s24',
    'Flagship Android phone',
    899.99,
    35,
    'PHONE-SGS24-001',
    '{"brand": "Samsung", "warranty_years": 1, "specs": {"storage": "256GB", "color": "Black"}}'::jsonb
),
(
    (SELECT category_id FROM categories WHERE slug = 'men-clothing'),
    'Levi''s 501 Jeans',
    'levis-501-jeans',
    'Classic straight fit jeans',
    79.99,
    100,
    'CLOTH-LV501-001',
    '{"brand": "Levis", "sizes": ["30", "32", "34", "36"], "color": "Blue"}'::jsonb
);

-- Insert addresses
INSERT INTO addresses (user_id, address_type, street_address, city, state, postal_code, country, is_default)
SELECT user_id, 'shipping', '123 Main St', 'New York', 'NY', '10001', 'USA', true
FROM users WHERE email = 'john.doe@email.com'
UNION ALL
SELECT user_id, 'billing', '456 Oak Ave', 'Los Angeles', 'CA', '90001', 'USA', false
FROM users WHERE email = 'jane.smith@email.com';

-- Insert orders
INSERT INTO orders (user_id, status, total_amount, shipping_address_id, payment_method)
SELECT 
    u.user_id,
    'delivered',
    2579.98,
    a.address_id,
    'credit_card'
FROM users u
JOIN addresses a ON u.user_id = a.user_id
WHERE u.email = 'john.doe@email.com' AND a.is_default = true;

INSERT INTO orders (user_id, status, total_amount, payment_method)
SELECT user_id, 'processing', 899.99, 'paypal'
FROM users WHERE email = 'jane.smith@email.com';

-- Insert order items
INSERT INTO order_items (order_id, product_id, quantity, unit_price, subtotal)
SELECT 
    o.order_id,
    p.product_id,
    1,
    p.price,
    p.price
FROM orders o
JOIN users u ON o.user_id = u.user_id
JOIN products p ON p.slug = 'macbook-pro-16'
WHERE u.email = 'john.doe@email.com'
LIMIT 1;

INSERT INTO order_items (order_id, product_id, quantity, unit_price, subtotal)
SELECT 
    o.order_id,
    p.product_id,
    1,
    p.price,
    p.price
FROM orders o
JOIN users u ON o.user_id = u.user_id
JOIN products p ON p.slug = 'levis-501-jeans'
WHERE u.email = 'john.doe@email.com'
LIMIT 1;

-- Insert reviews
INSERT INTO reviews (product_id, user_id, rating, title, comment, is_verified_purchase)
SELECT 
    p.product_id,
    u.user_id,
    5,
    'Excellent laptop!',
    'Best laptop I have ever owned. Fast and reliable.',
    true
FROM products p
JOIN users u ON u.email = 'john.doe@email.com'
WHERE p.slug = 'macbook-pro-16';


-- ============================================================================
-- SECTION 6: BASIC QUERIES (SELECT)
-- ============================================================================

-- Select all
SELECT * FROM products;

-- Select specific columns
SELECT product_id, name, price FROM products;

-- Count records
SELECT COUNT(*) FROM products;

-- Select with alias
SELECT name AS product_name, price AS product_price FROM products;


-- ============================================================================
-- SECTION 7: FILTERING (WHERE clause)
-- ============================================================================

-- Simple WHERE
SELECT * FROM products WHERE price > 1000;

-- Multiple conditions (AND)
SELECT * FROM products WHERE price > 500 AND stock_quantity > 20;

-- OR condition
SELECT * FROM products WHERE price < 100 OR stock_quantity > 80;

-- IN operator
SELECT * FROM products WHERE sku IN ('LAPTOP-MBP16-001', 'PHONE-IP15P-001');

-- BETWEEN operator
SELECT * FROM products WHERE price BETWEEN 500 AND 1500;

-- LIKE pattern matching (case-sensitive)
SELECT * FROM products WHERE name LIKE '%Pro%';

-- ILIKE pattern matching (case-insensitive - PostgreSQL specific)
SELECT * FROM products WHERE name ILIKE '%macbook%';

-- IS NULL / IS NOT NULL
SELECT * FROM products WHERE description IS NOT NULL;

-- NOT operator
SELECT * FROM products WHERE NOT is_active;


-- ============================================================================
-- SECTION 8: SORTING (ORDER BY)
-- ============================================================================

-- Sort ascending (default)
SELECT name, price FROM products ORDER BY price;

-- Sort descending
SELECT name, price FROM products ORDER BY price DESC;

-- Multiple columns
SELECT name, price, stock_quantity 
FROM products 
ORDER BY price DESC, stock_quantity ASC;

-- Sort with NULL handling
SELECT * FROM categories ORDER BY parent_category_id NULLS FIRST;


-- ============================================================================
-- SECTION 9: LIMITING RESULTS
-- ============================================================================

-- LIMIT (top N results)
SELECT * FROM products ORDER BY price DESC LIMIT 3;

-- OFFSET (pagination)
SELECT * FROM products ORDER BY created_at DESC LIMIT 10 OFFSET 0;  -- Page 1
SELECT * FROM products ORDER BY created_at DESC LIMIT 10 OFFSET 10; -- Page 2

-- FETCH (SQL standard alternative to LIMIT)
SELECT * FROM products ORDER BY price DESC FETCH FIRST 5 ROWS ONLY;


-- ============================================================================
-- SECTION 10: AGGREGATE FUNCTIONS
-- ============================================================================

-- COUNT
SELECT COUNT(*) AS total_products FROM products;
SELECT COUNT(DISTINCT category_id) AS total_categories FROM products;

-- SUM
SELECT SUM(stock_quantity) AS total_stock FROM products;
SELECT SUM(total_amount) AS total_revenue FROM orders WHERE status = 'delivered';

-- AVG
SELECT AVG(price) AS average_price FROM products;
SELECT ROUND(AVG(rating)::numeric, 2) AS avg_rating FROM reviews;

-- MIN and MAX
SELECT MIN(price) AS cheapest, MAX(price) AS most_expensive FROM products;

-- Multiple aggregates
SELECT 
    COUNT(*) AS total_products,
    AVG(price) AS avg_price,
    MIN(price) AS min_price,
    MAX(price) AS max_price,
    SUM(stock_quantity) AS total_stock
FROM products;


-- ============================================================================
-- SECTION 11: GROUP BY
-- ============================================================================

-- Group by single column
SELECT category_id, COUNT(*) AS product_count
FROM products
GROUP BY category_id;

-- Group by with aggregate
SELECT 
    category_id,
    COUNT(*) AS product_count,
    AVG(price) AS avg_price,
    SUM(stock_quantity) AS total_stock
FROM products
GROUP BY category_id;

-- Group by multiple columns
SELECT 
    category_id,
    is_active,
    COUNT(*) AS count
FROM products
GROUP BY category_id, is_active;


-- ============================================================================
-- SECTION 12: HAVING (Filter after GROUP BY)
-- ============================================================================

-- Filter groups
SELECT category_id, COUNT(*) AS product_count
FROM products
GROUP BY category_id
HAVING COUNT(*) > 1;

-- HAVING with aggregates
SELECT 
    category_id,
    AVG(price) AS avg_price
FROM products
GROUP BY category_id
HAVING AVG(price) > 500;

-- WHERE vs HAVING (WHERE filters rows, HAVING filters groups)
SELECT 
    category_id,
    COUNT(*) AS product_count
FROM products
WHERE is_active = true
GROUP BY category_id
HAVING COUNT(*) >= 2;


-- ============================================================================
-- SECTION 13: JOINS (Most Important)
-- ============================================================================

-- INNER JOIN (only matching records)
SELECT 
    p.name AS product_name,
    c.name AS category_name,
    p.price
FROM products p
INNER JOIN categories c ON p.category_id = c.category_id;

-- LEFT JOIN (all from left table)
SELECT 
    c.name AS category_name,
    COUNT(p.product_id) AS product_count
FROM categories c
LEFT JOIN products p ON c.category_id = p.category_id
GROUP BY c.name;

-- RIGHT JOIN (all from right table)
SELECT 
    u.full_name,
    o.order_id,
    o.total_amount
FROM orders o
RIGHT JOIN users u ON o.user_id = u.user_id;

-- FULL OUTER JOIN (all records from both tables)
SELECT 
    u.full_name,
    o.order_id
FROM users u
FULL OUTER JOIN orders o ON u.user_id = o.user_id;

-- Multiple joins
SELECT 
    o.order_id,
    u.full_name AS customer_name,
    p.name AS product_name,
    oi.quantity,
    oi.unit_price
FROM orders o
JOIN users u ON o.user_id = u.user_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id;

-- Self join (hierarchical categories)
SELECT 
    c1.name AS category,
    c2.name AS parent_category
FROM categories c1
LEFT JOIN categories c2 ON c1.parent_category_id = c2.category_id;


-- ============================================================================
-- SECTION 14: SUBQUERIES
-- ============================================================================

-- Subquery in WHERE
SELECT * FROM products
WHERE category_id IN (
    SELECT category_id FROM categories WHERE name = 'Electronics'
);

-- Subquery in SELECT (scalar subquery)
SELECT 
    name,
    price,
    (SELECT AVG(price) FROM products) AS avg_price,
    price - (SELECT AVG(price) FROM products) AS price_diff
FROM products;

-- Subquery in FROM (derived table)
SELECT 
    category_name,
    avg_price
FROM (
    SELECT 
        c.name AS category_name,
        AVG(p.price) AS avg_price
    FROM products p
    JOIN categories c ON p.category_id = c.category_id
    GROUP BY c.name
) AS category_stats
WHERE avg_price > 500;

-- Correlated subquery
SELECT 
    p1.name,
    p1.price
FROM products p1
WHERE p1.price > (
    SELECT AVG(p2.price)
    FROM products p2
    WHERE p2.category_id = p1.category_id
);

-- EXISTS subquery
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.user_id
);


-- ============================================================================
-- SECTION 15: COMMON TABLE EXPRESSIONS (CTEs)
-- ============================================================================

-- Simple CTE
WITH expensive_products AS (
    SELECT * FROM products WHERE price > 1000
)
SELECT name, price FROM expensive_products;

-- Multiple CTEs
WITH 
user_stats AS (
    SELECT 
        user_id,
        COUNT(*) AS order_count,
        SUM(total_amount) AS total_spent
    FROM orders
    GROUP BY user_id
),
high_value_customers AS (
    SELECT * FROM user_stats WHERE total_spent > 1000
)
SELECT 
    u.full_name,
    hvc.order_count,
    hvc.total_spent
FROM high_value_customers hvc
JOIN users u ON hvc.user_id = u.user_id;

-- Recursive CTE (category hierarchy)
WITH RECURSIVE category_tree AS (
    -- Base case: root categories
    SELECT category_id, name, parent_category_id, 0 AS level
    FROM categories
    WHERE parent_category_id IS NULL
    
    UNION ALL
    
    -- Recursive case: child categories
    SELECT c.category_id, c.name, c.parent_category_id, ct.level + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_category_id = ct.category_id
)
SELECT * FROM category_tree ORDER BY level, name;


-- ============================================================================
-- SECTION 16: WINDOW FUNCTIONS
-- ============================================================================

-- ROW_NUMBER (assign unique row numbers)
SELECT 
    name,
    price,
    ROW_NUMBER() OVER (ORDER BY price DESC) AS price_rank
FROM products;

-- RANK (with gaps for ties)
SELECT 
    name,
    price,
    RANK() OVER (ORDER BY price DESC) AS price_rank
FROM products;

-- DENSE_RANK (without gaps)
SELECT 
    name,
    price,
    DENSE_RANK() OVER (ORDER BY price DESC) AS price_rank
FROM products;

-- PARTITION BY (rank within groups)
SELECT 
    name,
    category_id,
    price,
    RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS category_rank
FROM products;

-- LAG (previous row value)
SELECT 
    name,
    price,
    LAG(price) OVER (ORDER BY price) AS previous_price,
    price - LAG(price) OVER (ORDER BY price) AS price_diff
FROM products;

-- LEAD (next row value)
SELECT 
    name,
    price,
    LEAD(price) OVER (ORDER BY price) AS next_price
FROM products;

-- Running total
SELECT 
    order_id,
    total_amount,
    SUM(total_amount) OVER (ORDER BY created_at) AS running_total
FROM orders;


-- ============================================================================
-- SECTION 17: SET OPERATIONS
-- ============================================================================

-- UNION (combines and removes duplicates)
SELECT email FROM users WHERE is_active = true
UNION
SELECT email FROM users WHERE created_at > NOW() - INTERVAL '30 days';

-- UNION ALL (keeps duplicates)
SELECT 'customer' AS type, email FROM users
UNION ALL
SELECT 'order', order_id::text FROM orders;

-- INTERSECT (common records)
SELECT category_id FROM products
INTERSECT
SELECT category_id FROM categories WHERE parent_category_id IS NOT NULL;

-- EXCEPT (difference - in first but not in second)
SELECT user_id FROM users
EXCEPT
SELECT user_id FROM orders;


-- ============================================================================
-- SECTION 18: UPDATE OPERATIONS
-- ============================================================================

-- Simple UPDATE
UPDATE products 
SET price = 2599.99 
WHERE slug = 'macbook-pro-16';

-- UPDATE with calculation
UPDATE products 
SET price = price * 1.10 
WHERE category_id IN (SELECT category_id FROM categories WHERE slug = 'electronics');

-- UPDATE from SELECT (using subquery)
UPDATE products
SET stock_quantity = stock_quantity - 1
WHERE product_id IN (
    SELECT product_id FROM order_items WHERE order_id = (SELECT order_id FROM orders LIMIT 1)
);

-- UPDATE with JOIN (PostgreSQL style)
UPDATE products p
SET stock_quantity = 0
FROM categories c
WHERE p.category_id = c.category_id AND c.slug = 'discontinued';

-- UPDATE multiple columns
UPDATE users
SET 
    full_name = 'John Updated Doe',
    updated_at = NOW()
WHERE email = 'john.doe@email.com';


-- ============================================================================
-- SECTION 19: DELETE OPERATIONS
-- ============================================================================

-- Simple DELETE
DELETE FROM reviews WHERE rating < 2;

-- DELETE with condition
DELETE FROM products WHERE stock_quantity = 0 AND is_active = false;

-- DELETE with subquery
DELETE FROM order_items
WHERE order_id IN (
    SELECT order_id FROM orders WHERE status = 'cancelled'
);

-- DELETE with JOIN
DELETE FROM reviews r
USING products p
WHERE r.product_id = p.product_id AND p.is_active = false;


-- ============================================================================
-- SECTION 20: UPSERT (INSERT ON CONFLICT)
-- ============================================================================

-- INSERT or UPDATE if exists
INSERT INTO products (product_id, category_id, name, slug, price, stock_quantity, sku)
VALUES (
    uuid_generate_v4(),
    (SELECT category_id FROM categories WHERE slug = 'laptops'),
    'Test Laptop',
    'test-laptop',
    1000.00,
    10,
    'LAPTOP-TEST-001'
)
ON CONFLICT (sku) 
DO UPDATE SET 
    price = EXCLUDED.price,
    stock_quantity = EXCLUDED.stock_quantity,
    updated_at = NOW();

-- INSERT or DO NOTHING
INSERT INTO categories (name, slug, description)
VALUES ('Electronics', 'electronics', 'Electronic items')
ON CONFLICT (slug) DO NOTHING;


-- ============================================================================
-- SECTION 21: TRANSACTIONS
-- ============================================================================

-- Start transaction
BEGIN;

-- Insert order
INSERT INTO orders (user_id, status, total_amount, payment_method)
VALUES (
    (SELECT user_id FROM users WHERE email = 'john.doe@email.com'),
    'pending',
    999.99,
    'credit_card'
);

-- Insert order items
INSERT INTO order_items (order_id, product_id, quantity, unit_price, subtotal)
VALUES (
    (SELECT order_id FROM orders ORDER BY created_at DESC LIMIT 1),
    (SELECT product_id FROM products WHERE slug = 'iphone-15-pro'),
    1,
    999.99,
    999.99
);

-- Update stock
UPDATE products 
SET stock_quantity = stock_quantity - 1
WHERE slug = 'iphone-15-pro';

-- Commit or Rollback
COMMIT;
-- ROLLBACK;

-- Transaction with savepoint
BEGIN;
INSERT INTO categories (name, slug) VALUES ('Test', 'test');
SAVEPOINT my_savepoint;
UPDATE products SET price = 0; -- Oops, mistake
ROLLBACK TO SAVEPOINT my_savepoint;
COMMIT;


-- ============================================================================
-- SECTION 22: VIEWS
-- ============================================================================

-- Create simple view
CREATE OR REPLACE VIEW active_products AS
SELECT 
    p.product_id,
    p.name,
    p.price,
    p.stock_quantity,
    c.name AS category_name
FROM products p
JOIN categories c ON p.category_id = c.category_id
WHERE p.is_active = true;

-- Query view
SELECT * FROM active_products WHERE price > 500;

-- Create complex view
CREATE OR REPLACE VIEW order_summary AS
SELECT 
    o.order_id,
    u.full_name AS customer_name,
    u.email,
    o.status,
    o.total_amount,
    COUNT(oi.order_item_id) AS total_items,
    o.created_at
FROM orders o
JOIN users u ON o.user_id = u.user_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id, u.full_name, u.email, o.status, o.total_amount, o.created_at;

-- Drop view
-- DROP VIEW IF EXISTS active_products;


-- ============================================================================
-- SECTION 23: MATERIALIZED VIEWS (Cached results)
-- ============================================================================

-- Create materialized view
CREATE MATERIALIZED VIEW product_stats AS
SELECT 
    c.name AS category_name,
    COUNT(p.product_id) AS product_count,
    AVG(p.price) AS avg_price,
    SUM(p.stock_quantity) AS total_stock
FROM categories c
LEFT JOIN products p ON c.category_id = p.category_id
GROUP BY c.name;

-- Query materialized view
SELECT * FROM product_stats;

-- Refresh materialized view (update cached data)
REFRESH MATERIALIZED VIEW product_stats;

-- Concurrent refresh (non-blocking)
REFRESH MATERIALIZED VIEW CONCURRENTLY product_stats;


-- ============================================================================
-- SECTION 24: FUNCTIONS (User-defined)
-- ============================================================================

-- Simple function
CREATE OR REPLACE FUNCTION get_product_count()
RETURNS INTEGER AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM products);
END;
$$ LANGUAGE plpgsql;

-- Call function
SELECT get_product_count();

-- Function with parameters
CREATE OR REPLACE FUNCTION get_products_by_price_range(
    min_price NUMERIC,
    max_price NUMERIC
)
RETURNS TABLE(product_name VARCHAR, product_price NUMERIC) AS $$
BEGIN
    RETURN QUERY
    SELECT name, price
    FROM products
    WHERE price BETWEEN min_price AND max_price;
END;
$$ LANGUAGE plpgsql;

-- Call function with parameters
SELECT * FROM get_products_by_price_range(100, 1000);

-- Function to calculate order total
CREATE OR REPLACE FUNCTION calculate_order_total(order_id_param UUID)
RETURNS NUMERIC AS $$
DECLARE
    total NUMERIC;
BEGIN
    SELECT COALESCE(SUM(subtotal), 0) INTO total
    FROM order_items
    WHERE order_id = order_id_param;
    
    RETURN total;
END;
$$ LANGUAGE plpgsql;


-- ============================================================================
-- SECTION 25: TRIGGERS
-- ============================================================================

-- Trigger function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger to products table
CREATE TRIGGER update_products_updated_at
BEFORE UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Trigger to update order total
CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(subtotal), 0)
        FROM order_items
        WHERE order_id = NEW.order_id
    )
    WHERE order_id = NEW.order_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_order_total_trigger
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_total();


-- ============================================================================
-- SECTION 26: JSON OPERATIONS (PostgreSQL specific)
-- ============================================================================

-- Query JSONB field
SELECT name, metadata->>'brand' AS brand
FROM products
WHERE metadata IS NOT NULL;

-- JSONB contains
SELECT * FROM products
WHERE metadata @> '{"brand": "Apple"}';

-- JSONB array operations
SELECT * FROM products
WHERE metadata->'specs'->>'storage' = '256GB';

-- Update JSONB
UPDATE products
SET metadata = jsonb_set(metadata, '{warranty_years}', '2')
WHERE metadata->>'brand' = 'Apple';

-- JSONB aggregation
SELECT 
    metadata->>'brand' AS brand,
    COUNT(*) AS product_count,
    jsonb_agg(name) AS product_names
FROM products
WHERE metadata IS NOT NULL
GROUP BY metadata->>'brand';


-- ============================================================================
-- SECTION 27: QUERY PERFORMANCE ANALYSIS
-- ============================================================================

-- EXPLAIN (show query plan)
EXPLAIN SELECT * FROM products WHERE price > 1000;

-- EXPLAIN ANALYZE (execute and show actual performance)
EXPLAIN ANALYZE 
SELECT 
    p.name,
    c.name AS category_name
FROM products p
JOIN categories c ON p.category_id = c.category_id
WHERE p.price > 500;

-- Check index usage
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products WHERE sku = 'LAPTOP-MBP16-001';


-- ============================================================================
-- SECTION 28: USEFUL ADMIN QUERIES
-- ============================================================================

-- List all tables
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public';

-- Show table size
SELECT 
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- Show table row counts
SELECT 
    schemaname,
    tablename,
    n_live_tup AS row_count
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;

-- Show indexes
SELECT 
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY tablename, indexname;

-- Show active connections
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query
FROM pg_stat_activity
WHERE datname = current_database();

-- Kill a connection (if needed)
-- SELECT pg_terminate_backend(pid) WHERE pid = 12345;


-- ============================================================================
-- SECTION 29: VACUUM AND MAINTENANCE
-- ============================================================================

-- Vacuum table (reclaim storage)
VACUUM products;

-- Analyze table (update statistics for query planner)
ANALYZE products;

-- Vacuum and analyze
VACUUM ANALYZE products;

-- Full vacuum (more aggressive, locks table)
-- VACUUM FULL products;

-- Reindex (rebuild indexes)
REINDEX TABLE products;


-- ============================================================================
-- SECTION 30: BACKUP COMMANDS (run in terminal, not SQL)
-- ============================================================================

/*
-- Backup database
pg_dump -U postgres -d ecommerce_db -F c -b -v -f ecommerce_backup.dump

-- Restore database
pg_restore -U postgres -d ecommerce_db -v ecommerce_backup.dump

-- Backup specific table
pg_dump -U postgres -d ecommerce_db -t products -F c -f products_backup.dump

-- Export to SQL file
pg_dump -U postgres -d ecommerce_db -f ecommerce_backup.sql
*/


-- ============================================================================
-- SECTION 31: PRACTICAL REAL-WORLD QUERIES
-- ============================================================================

-- 1. Find top 5 customers by total spending
SELECT 
    u.full_name,
    u.email,
    COUNT(o.order_id) AS total_orders,
    SUM(o.total_amount) AS total_spent
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE o.status = 'delivered'
GROUP BY u.user_id, u.full_name, u.email
ORDER BY total_spent DESC
LIMIT 5;

-- 2. Products running low on stock
SELECT 
    name,
    sku,
    stock_quantity
FROM products
WHERE stock_quantity < 20 AND is_active = true
ORDER BY stock_quantity ASC;

-- 3. Monthly sales report
SELECT 
    DATE_TRUNC('month', created_at) AS month,
    COUNT(*) AS total_orders,
    SUM(total_amount) AS total_revenue,
    AVG(total_amount) AS avg_order_value
FROM orders
WHERE status = 'delivered'
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month DESC;

-- 4. Best selling products
SELECT 
    p.name,
    SUM(oi.quantity) AS total_sold,
    SUM(oi.subtotal) AS total_revenue
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
WHERE o.status = 'delivered'
GROUP BY p.product_id, p.name
ORDER BY total_sold DESC
LIMIT 10;

-- 5. Products never ordered
SELECT p.name, p.sku, p.price
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
WHERE oi.order_item_id IS NULL;

-- 6. Average rating per product with review count
SELECT 
    p.name,
    COUNT(r.review_id) AS review_count,
    ROUND(AVG(r.rating)::numeric, 2) AS avg_rating
FROM products p
LEFT JOIN reviews r ON p.product_id = r.product_id
GROUP BY p.product_id, p.name
HAVING COUNT(r.review_id) > 0
ORDER BY avg_rating DESC;

-- 7. Customers with no orders
SELECT 
    u.full_name,
    u.email,
    u.created_at
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
WHERE o.order_id IS NULL AND u.is_active = true;

-- 8. Order fulfillment time (for delivered orders)
SELECT 
    order_id,
    created_at AS order_date,
    updated_at AS delivered_date,
    updated_at - created_at AS fulfillment_time
FROM orders
WHERE status = 'delivered'
ORDER BY fulfillment_time;

-- 9. Category performance
SELECT 
    c.name AS category,
    COUNT(DISTINCT p.product_id) AS product_count,
    COUNT(DISTINCT oi.order_item_id) AS items_sold,
    COALESCE(SUM(oi.subtotal), 0) AS total_revenue
FROM categories c
LEFT JOIN products p ON c.category_id = p.category_id
LEFT JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY c.category_id, c.name
ORDER BY total_revenue DESC;

-- 10. Find duplicate emails (data quality check)
SELECT email, COUNT(*) AS count
FROM users
GROUP BY email
HAVING COUNT(*) > 1;


-- ============================================================================
-- END OF FILE
-- ============================================================================
